   1               		.file	"DPS310.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	make_signed_16
  12               	make_signed_16:
  13               	.LFB6:
  14               		.file 1 "DPS310.c"
   1:DPS310.c      **** #include <util/delay.h>
   2:DPS310.c      **** #include <math.h>
   3:DPS310.c      **** #include <avr/interrupt.h>
   4:DPS310.c      **** #include "grn_TWI.h"
   5:DPS310.c      **** #include <inttypes.h>
   6:DPS310.c      **** 
   7:DPS310.c      **** 
   8:DPS310.c      **** 
   9:DPS310.c      **** 
  10:DPS310.c      **** #define DPS310_W 0xEC	//Adresse DPS310
  11:DPS310.c      **** #define DPS310_R 0xED
  12:DPS310.c      **** 
  13:DPS310.c      **** #define PSR_B2	0x00
  14:DPS310.c      **** #define PSR_B1	0x01
  15:DPS310.c      **** #define PSR_B0	0x02
  16:DPS310.c      **** #define TMP_B2 	0x03
  17:DPS310.c      **** #define TMP_B1	0x04
  18:DPS310.c      **** #define TMP_B0	0x05
  19:DPS310.c      **** #define PRS_CFG	0x06
  20:DPS310.c      **** #define TMP_CFG	0x07
  21:DPS310.c      **** #define MEAS_CFG	0x08
  22:DPS310.c      **** #define CFG_REG		0x09
  23:DPS310.c      **** #define INT_STS		0x0A
  24:DPS310.c      **** #define FIFO_STS	0x0B
  25:DPS310.c      **** #define RESET		0x0C
  26:DPS310.c      **** #define Product_ID	0x0D
  27:DPS310.c      **** #define COEF_SRCE	0x28
  28:DPS310.c      **** 
  29:DPS310.c      **** #define MODE_STBY	0x00
  30:DPS310.c      **** #define MODE_COMMAND_PRES 0x01
  31:DPS310.c      **** #define MODE_COMMAND_TEMP 0x02
  32:DPS310.c      **** #define MODE_COMMAND_PRES_AND_TEMP 0x03
  33:DPS310.c      **** #define MODE_BACKGROUND_PRES 0x05
  34:DPS310.c      **** #define MODE_BACKGROUND_TEMP 0x06
  35:DPS310.c      **** #define MODE_BACKGROUND_PRES_AND_TEMP 0x07
  36:DPS310.c      **** 
  37:DPS310.c      **** //Kompensationskoefizienten
  38:DPS310.c      **** uint16_t C0=0; 
  39:DPS310.c      **** uint16_t C1=0; 
  40:DPS310.c      **** 
  41:DPS310.c      **** 
  42:DPS310.c      **** int16_t make_signed_16(uint8_t high_byte, uint8_t low_byte)
  43:DPS310.c      **** {
  15               		.loc 1 43 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  44:DPS310.c      **** 	uint16_t tmpvar=0;// roh zahl unsigned aus 2er Komplement
  45:DPS310.c      **** 	int16_t ret=0;//return variable signed
  46:DPS310.c      **** 	tmpvar=(((uint16_t)high_byte)<<8 | low_byte); //schiftet 8
  47:DPS310.c      **** 	
  48:DPS310.c      **** 	if(tmpvar>=32768)//Vorzeichenbit gesetzt?
  22               		.loc 1 48 0
  23 0000 982F      		mov r25,r24
  24 0002 862F      		mov r24,r22
  25               	.LVL1:
  26 0004 97FF      		sbrs r25,7
  27 0006 00C0      		rjmp .L1
  28               	.LVL2:
  49:DPS310.c      **** 	{
  50:DPS310.c      **** 		tmpvar -=32768;//Wertigkeit von Vorzeichenbit abzählen
  29               		.loc 1 50 0
  30 0008 9058      		subi r25,-128
  31               	.LVL3:
  51:DPS310.c      **** 		ret = 0 -((int16_t)tmpvar);
  32               		.loc 1 51 0
  33 000a 9195      		neg r25
  34 000c 8195      		neg r24
  35 000e 9109      		sbc r25,__zero_reg__
  36               	.LVL4:
  37               	.L1:
  38               	/* epilogue start */
  52:DPS310.c      **** 	}else ret = (int16_t)tmpvar;
  53:DPS310.c      **** 	return ret;
  54:DPS310.c      **** }
  39               		.loc 1 54 0
  40 0010 0895      		ret
  41               		.cfi_endproc
  42               	.LFE6:
  44               	.global	DPS310_read_8
  46               	DPS310_read_8:
  47               	.LFB7:
  55:DPS310.c      **** uint8_t DPS310_read_8(uint8_t reg)
  56:DPS310.c      **** {
  48               		.loc 1 56 0
  49               		.cfi_startproc
  50               	.LVL5:
  51 0012 CF93      		push r28
  52               	.LCFI0:
  53               		.cfi_def_cfa_offset 3
  54               		.cfi_offset 28, -2
  55               	/* prologue: function */
  56               	/* frame size = 0 */
  57               	/* stack size = 1 */
  58               	.L__stack_usage = 1
  59 0014 C82F      		mov r28,r24
  60               	.LVL6:
  57:DPS310.c      **** 		uint8_t result=0;
  58:DPS310.c      **** 		
  59:DPS310.c      **** 		TWIStart();
  61               		.loc 1 59 0
  62 0016 0E94 0000 		call TWIStart
  63               	.LVL7:
  60:DPS310.c      **** 		if(TWIGetStatus() != 0x08)return 123;
  64               		.loc 1 60 0
  65 001a 0E94 0000 		call TWIGetStatus
  66               	.LVL8:
  67 001e 8830      		cpi r24,lo8(8)
  68 0020 01F4      		brne .L5
  61:DPS310.c      **** 		TWIWrite(DPS310_W);
  69               		.loc 1 61 0
  70 0022 8CEE      		ldi r24,lo8(-20)
  71 0024 0E94 0000 		call TWIWrite
  72               	.LVL9:
  62:DPS310.c      **** 		if(TWIGetStatus() != 0x18)return 2;
  73               		.loc 1 62 0
  74 0028 0E94 0000 		call TWIGetStatus
  75               	.LVL10:
  76 002c 8831      		cpi r24,lo8(24)
  77 002e 01F4      		brne .L6
  63:DPS310.c      **** 		TWIWrite(reg);
  78               		.loc 1 63 0
  79 0030 8C2F      		mov r24,r28
  80 0032 0E94 0000 		call TWIWrite
  81               	.LVL11:
  64:DPS310.c      **** 		if(TWIGetStatus() != 0x28)return 3;
  82               		.loc 1 64 0
  83 0036 0E94 0000 		call TWIGetStatus
  84               	.LVL12:
  85 003a C3E0      		ldi r28,lo8(3)
  86               	.LVL13:
  87 003c 8832      		cpi r24,lo8(40)
  88 003e 01F4      		brne .L3
  65:DPS310.c      **** 		TWIStart();
  89               		.loc 1 65 0
  90 0040 0E94 0000 		call TWIStart
  91               	.LVL14:
  66:DPS310.c      **** 		if(TWIGetStatus() != 0x10)return 4; //repetet Start sent?
  92               		.loc 1 66 0
  93 0044 0E94 0000 		call TWIGetStatus
  94               	.LVL15:
  95 0048 C4E0      		ldi r28,lo8(4)
  96 004a 8031      		cpi r24,lo8(16)
  97 004c 01F4      		brne .L3
  67:DPS310.c      **** 		TWIWrite(DPS310_R);
  98               		.loc 1 67 0
  99 004e 8DEE      		ldi r24,lo8(-19)
 100 0050 0E94 0000 		call TWIWrite
 101               	.LVL16:
  68:DPS310.c      **** 		if(TWIGetStatus() != 0x40)return 5;
 102               		.loc 1 68 0
 103 0054 0E94 0000 		call TWIGetStatus
 104               	.LVL17:
 105 0058 C5E0      		ldi r28,lo8(5)
 106 005a 8034      		cpi r24,lo8(64)
 107 005c 01F4      		brne .L3
 108               	.LVL18:
 109               	.LBB44:
 110               	.LBB45:
  69:DPS310.c      **** 		result=TWIReadNACK();
 111               		.loc 1 69 0
 112 005e 0E94 0000 		call TWIReadNACK
 113               	.LVL19:
 114 0062 C82F      		mov r28,r24
 115               	.LVL20:
  70:DPS310.c      **** 		TWIStop();
 116               		.loc 1 70 0
 117 0064 0E94 0000 		call TWIStop
 118               	.LVL21:
 119               	.L3:
 120               	.LBE45:
 121               	.LBE44:
  71:DPS310.c      **** 	return result;	
  72:DPS310.c      **** 								//Daten zurueckgeben
  73:DPS310.c      **** }
 122               		.loc 1 73 0
 123 0068 8C2F      		mov r24,r28
 124               	/* epilogue start */
 125 006a CF91      		pop r28
 126 006c 0895      		ret
 127               	.LVL22:
 128               	.L5:
  60:DPS310.c      **** 		TWIWrite(DPS310_W);
 129               		.loc 1 60 0
 130 006e CBE7      		ldi r28,lo8(123)
 131               	.LVL23:
 132 0070 00C0      		rjmp .L3
 133               	.LVL24:
 134               	.L6:
  62:DPS310.c      **** 		TWIWrite(reg);
 135               		.loc 1 62 0
 136 0072 C2E0      		ldi r28,lo8(2)
 137               	.LVL25:
 138 0074 00C0      		rjmp .L3
 139               		.cfi_endproc
 140               	.LFE7:
 142               	.global	DPS310_write
 144               	DPS310_write:
 145               	.LFB8:
  74:DPS310.c      **** uint8_t DPS310_write(uint8_t reg, uint8_t data)
  75:DPS310.c      **** {
 146               		.loc 1 75 0
 147               		.cfi_startproc
 148               	.LVL26:
 149 0076 CF93      		push r28
 150               	.LCFI1:
 151               		.cfi_def_cfa_offset 3
 152               		.cfi_offset 28, -2
 153 0078 DF93      		push r29
 154               	.LCFI2:
 155               		.cfi_def_cfa_offset 4
 156               		.cfi_offset 29, -3
 157               	/* prologue: function */
 158               	/* frame size = 0 */
 159               	/* stack size = 2 */
 160               	.L__stack_usage = 2
 161 007a D82F      		mov r29,r24
 162 007c C62F      		mov r28,r22
  76:DPS310.c      **** 		TWIStart();
 163               		.loc 1 76 0
 164 007e 0E94 0000 		call TWIStart
 165               	.LVL27:
  77:DPS310.c      **** 		if(TWIGetStatus() != 0x08)return 11;
 166               		.loc 1 77 0
 167 0082 0E94 0000 		call TWIGetStatus
 168               	.LVL28:
 169 0086 8830      		cpi r24,lo8(8)
 170 0088 01F4      		brne .L12
  78:DPS310.c      **** 		TWIWrite(DPS310_W);
 171               		.loc 1 78 0
 172 008a 8CEE      		ldi r24,lo8(-20)
 173 008c 0E94 0000 		call TWIWrite
 174               	.LVL29:
  79:DPS310.c      **** 		if(TWIGetStatus() != 0x18)return 22;
 175               		.loc 1 79 0
 176 0090 0E94 0000 		call TWIGetStatus
 177               	.LVL30:
 178 0094 8831      		cpi r24,lo8(24)
 179 0096 01F4      		brne .L13
  80:DPS310.c      **** 		TWIWrite(reg);
 180               		.loc 1 80 0
 181 0098 8D2F      		mov r24,r29
 182 009a 0E94 0000 		call TWIWrite
 183               	.LVL31:
  81:DPS310.c      **** 		if(TWIGetStatus() != 0x28)return 33;
 184               		.loc 1 81 0
 185 009e 0E94 0000 		call TWIGetStatus
 186               	.LVL32:
 187 00a2 8832      		cpi r24,lo8(40)
 188 00a4 01F4      		brne .L14
 189               	.LVL33:
 190               	.LBB48:
 191               	.LBB49:
  82:DPS310.c      **** 		TWIWrite(data);
 192               		.loc 1 82 0
 193 00a6 8C2F      		mov r24,r28
 194 00a8 0E94 0000 		call TWIWrite
 195               	.LVL34:
  83:DPS310.c      **** 		if(TWIGetStatus() != 0x28)return 44;
 196               		.loc 1 83 0
 197 00ac 0E94 0000 		call TWIGetStatus
 198               	.LVL35:
 199 00b0 8832      		cpi r24,lo8(40)
 200 00b2 01F4      		brne .L15
  84:DPS310.c      **** 		TWIStop();
 201               		.loc 1 84 0
 202 00b4 0E94 0000 		call TWIStop
 203               	.LVL36:
  85:DPS310.c      **** 	return 0;	
 204               		.loc 1 85 0
 205 00b8 80E0      		ldi r24,0
 206               	.LVL37:
 207               	.L10:
 208               	/* epilogue start */
 209               	.LBE49:
 210               	.LBE48:
  86:DPS310.c      **** 	
  87:DPS310.c      **** 	//Daten zurueckgeben
  88:DPS310.c      **** }
 211               		.loc 1 88 0
 212 00ba DF91      		pop r29
 213               	.LVL38:
 214 00bc CF91      		pop r28
 215               	.LVL39:
 216 00be 0895      		ret
 217               	.LVL40:
 218               	.L12:
  77:DPS310.c      **** 		TWIWrite(DPS310_W);
 219               		.loc 1 77 0
 220 00c0 8BE0      		ldi r24,lo8(11)
 221 00c2 00C0      		rjmp .L10
 222               	.L13:
  79:DPS310.c      **** 		TWIWrite(reg);
 223               		.loc 1 79 0
 224 00c4 86E1      		ldi r24,lo8(22)
 225 00c6 00C0      		rjmp .L10
 226               	.L14:
  81:DPS310.c      **** 		TWIWrite(data);
 227               		.loc 1 81 0
 228 00c8 81E2      		ldi r24,lo8(33)
 229 00ca 00C0      		rjmp .L10
 230               	.LVL41:
 231               	.L15:
 232               	.LBB51:
 233               	.LBB50:
  83:DPS310.c      **** 		TWIStop();
 234               		.loc 1 83 0
 235 00cc 8CE2      		ldi r24,lo8(44)
 236 00ce 00C0      		rjmp .L10
 237               	.LBE50:
 238               	.LBE51:
 239               		.cfi_endproc
 240               	.LFE8:
 242               	.global	DPS310_init
 244               	DPS310_init:
 245               	.LFB9:
  89:DPS310.c      **** uint16_t DPS310_init(void)
  90:DPS310.c      **** {
 246               		.loc 1 90 0
 247               		.cfi_startproc
 248 00d0 CF93      		push r28
 249               	.LCFI3:
 250               		.cfi_def_cfa_offset 3
 251               		.cfi_offset 28, -2
 252 00d2 DF93      		push r29
 253               	.LCFI4:
 254               		.cfi_def_cfa_offset 4
 255               		.cfi_offset 29, -3
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 2 */
 259               	.L__stack_usage = 2
  91:DPS310.c      **** 	
  92:DPS310.c      **** 	DPS310_write(0x07, 0x00);//1 Messung / sec 8 mal oversampling
 260               		.loc 1 92 0
 261 00d4 60E0      		ldi r22,0
 262 00d6 87E0      		ldi r24,lo8(7)
 263 00d8 0E94 0000 		call DPS310_write
 264               	.LVL42:
 265               	.LBB52:
 266               	.LBB53:
 267               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 268               		.loc 2 187 0
 269 00dc 2FEF      		ldi r18,lo8(319999)
 270 00de 31EE      		ldi r19,hi8(319999)
 271 00e0 84E0      		ldi r24,hlo8(319999)
 272 00e2 2150      	1:	subi r18,1
 273 00e4 3040      		sbci r19,0
 274 00e6 8040      		sbci r24,0
 275 00e8 01F4      		brne 1b
 276 00ea 00C0      		rjmp .
 277 00ec 0000      		nop
 278               	.LVL43:
 279               	.LBE53:
 280               	.LBE52:
  93:DPS310.c      **** 	_delay_ms(100);
  94:DPS310.c      **** 	DPS310_write(0x08, 0x07);
 281               		.loc 1 94 0
 282 00ee 67E0      		ldi r22,lo8(7)
 283 00f0 88E0      		ldi r24,lo8(8)
 284 00f2 0E94 0000 		call DPS310_write
 285               	.LVL44:
 286               	.LBB54:
 287               	.LBB55:
 288               		.loc 2 187 0
 289 00f6 9FEF      		ldi r25,lo8(319999)
 290 00f8 21EE      		ldi r18,hi8(319999)
 291 00fa 34E0      		ldi r19,hlo8(319999)
 292 00fc 9150      	1:	subi r25,1
 293 00fe 2040      		sbci r18,0
 294 0100 3040      		sbci r19,0
 295 0102 01F4      		brne 1b
 296 0104 00C0      		rjmp .
 297 0106 0000      		nop
 298               	.LVL45:
 299               	.LBE55:
 300               	.LBE54:
  95:DPS310.c      **** 	_delay_ms(100);
  96:DPS310.c      **** 	DPS310_write(0x08, 0x07);
 301               		.loc 1 96 0
 302 0108 67E0      		ldi r22,lo8(7)
 303 010a 88E0      		ldi r24,lo8(8)
 304 010c 0E94 0000 		call DPS310_write
 305               	.LVL46:
 306               	.LBB56:
 307               	.LBB57:
 308               		.loc 2 187 0
 309 0110 8FE3      		ldi r24,lo8(-25537)
 310 0112 9CE9      		ldi r25,hi8(-25537)
 311 0114 0197      	1:	sbiw r24,1
 312 0116 01F4      		brne 1b
 313 0118 00C0      		rjmp .
 314 011a 0000      		nop
 315               	.LVL47:
 316               	.LBE57:
 317               	.LBE56:
  97:DPS310.c      **** 	_delay_ms(10);
  98:DPS310.c      **** 		
  99:DPS310.c      **** 	/*
 100:DPS310.c      **** 	 * Auslesen und Umrechnung Kalibrationskoeffizienten in Dezimal Werte
 101:DPS310.c      **** 	 * */
 102:DPS310.c      **** 	 
 103:DPS310.c      **** 	 uint8_t ut1=0;
 104:DPS310.c      **** 	 uint8_t ut2=0;
 105:DPS310.c      **** 	 uint8_t ut3=0;
 106:DPS310.c      **** 	 
 107:DPS310.c      **** 	 ut1 = DPS310_read_8(0x10);	//Bit 4-11 von C0
 318               		.loc 1 107 0
 319 011c 80E1      		ldi r24,lo8(16)
 320 011e 0E94 0000 		call DPS310_read_8
 321               	.LVL48:
 322 0122 C82F      		mov r28,r24
 323               	.LVL49:
 324               	.LBB58:
 325               	.LBB59:
 326               		.loc 2 187 0
 327 0124 9FEF      		ldi r25,lo8(319999)
 328 0126 21EE      		ldi r18,hi8(319999)
 329 0128 34E0      		ldi r19,hlo8(319999)
 330 012a 9150      	1:	subi r25,1
 331 012c 2040      		sbci r18,0
 332 012e 3040      		sbci r19,0
 333 0130 01F4      		brne 1b
 334 0132 00C0      		rjmp .
 335 0134 0000      		nop
 336               	.LVL50:
 337               	.LBE59:
 338               	.LBE58:
 108:DPS310.c      **** 	 _delay_ms(100);
 109:DPS310.c      **** 	 ut2 = DPS310_read_8(0x11);//Bit 4-7 im Register sind Bit 0-3 in C0 / Bit 0-3 in Register sind Bit
 339               		.loc 1 109 0
 340 0136 81E1      		ldi r24,lo8(17)
 341               	.LVL51:
 342 0138 0E94 0000 		call DPS310_read_8
 343               	.LVL52:
 344 013c D82F      		mov r29,r24
 345               	.LVL53:
 346               	.LBB60:
 347               	.LBB61:
 348               		.loc 2 187 0
 349 013e 8FEF      		ldi r24,lo8(319999)
 350 0140 91EE      		ldi r25,hi8(319999)
 351 0142 24E0      		ldi r18,hlo8(319999)
 352 0144 8150      	1:	subi r24,1
 353 0146 9040      		sbci r25,0
 354 0148 2040      		sbci r18,0
 355 014a 01F4      		brne 1b
 356               	.LVL54:
 357 014c 00C0      		rjmp .
 358 014e 0000      		nop
 359               	.LVL55:
 360               	.LBE61:
 361               	.LBE60:
 110:DPS310.c      **** 	 _delay_ms(100);
 111:DPS310.c      **** 	 ut3 = DPS310_read_8(0x12);//Bit 0-7 in C1
 362               		.loc 1 111 0
 363 0150 82E1      		ldi r24,lo8(18)
 364 0152 0E94 0000 		call DPS310_read_8
 365               	.LVL56:
 366               	.LBB62:
 367               	.LBB63:
 368               		.loc 2 187 0
 369 0156 3FEF      		ldi r19,lo8(319999)
 370 0158 91EE      		ldi r25,hi8(319999)
 371 015a 24E0      		ldi r18,hlo8(319999)
 372 015c 3150      	1:	subi r19,1
 373 015e 9040      		sbci r25,0
 374 0160 2040      		sbci r18,0
 375 0162 01F4      		brne 1b
 376 0164 00C0      		rjmp .
 377 0166 0000      		nop
 378               	.LVL57:
 379               	.LBE63:
 380               	.LBE62:
 112:DPS310.c      **** 	 _delay_ms(100);
 113:DPS310.c      **** 	 
 114:DPS310.c      **** 	 uint16_t t_16_1=0;
 115:DPS310.c      **** 	 
 116:DPS310.c      **** 	 t_16_1 = (ut2>>4);		 //4 mal nach rechts da nur die obersten 4 bits aus diesem Register zu C0 geh
 117:DPS310.c      **** 	 C0 = (ut1<<4) | t_16_1; //Zusammensetzten der 12 Bit Zahl 
 381               		.loc 1 117 0
 382 0168 90E1      		ldi r25,lo8(16)
 383 016a C99F      		mul r28,r25
 384 016c 9001      		movw r18,r0
 385 016e 1124      		clr __zero_reg__
 116:DPS310.c      **** 	 C0 = (ut1<<4) | t_16_1; //Zusammensetzten der 12 Bit Zahl 
 386               		.loc 1 116 0
 387 0170 9D2F      		mov r25,r29
 388 0172 9295      		swap r25
 389 0174 9F70      		andi r25,lo8(15)
 390               		.loc 1 117 0
 391 0176 292B      		or r18,r25
 392 0178 3093 0000 		sts C0+1,r19
 393 017c 2093 0000 		sts C0,r18
 394               	.LVL58:
 118:DPS310.c      **** 	//C0=(((int)ut1<<8)|ut2)>>4;
 119:DPS310.c      ****       // C0=C0/2;
 120:DPS310.c      **** 	 t_16_1 = 0; 			//Hilfsvariable zurücksetzen
 121:DPS310.c      **** 	 t_16_1 = ut2 & 0x0F; 	//nur die tiefsten 4 Bits übernehmen
 395               		.loc 1 121 0
 396 0180 DF70      		andi r29,lo8(15)
 397               	.LVL59:
 122:DPS310.c      **** 	 C1 = (t_16_1<< 8) | ut3;	//12 Bits zusammensetzen
 398               		.loc 1 122 0
 399 0182 9D2F      		mov r25,r29
 400 0184 9093 0000 		sts C1+1,r25
 401 0188 8093 0000 		sts C1,r24
 123:DPS310.c      **** 	 
 124:DPS310.c      **** 	return C0;
 125:DPS310.c      **** 		
 126:DPS310.c      **** 	//16Bite Werte
 127:DPS310.c      **** 	/*
 128:DPS310.c      **** 	tmp1=DPS310_read_8(0x18);
 129:DPS310.c      **** 	_delay_ms(verz);
 130:DPS310.c      **** 	tmp2=DPS310_read_8(0x19);
 131:DPS310.c      **** 	_delay_ms(verz);
 132:DPS310.c      **** 	C01 = make_signed_16(tmp1, tmp2);
 133:DPS310.c      **** 	tmp1=DPS310_read_8(0x1A);
 134:DPS310.c      **** 	_delay_ms(verz);
 135:DPS310.c      **** 	tmp2=DPS310_read_8(0x1B);
 136:DPS310.c      **** 	_delay_ms(verz);
 137:DPS310.c      **** 	C11 = make_signed_16(tmp1, tmp2);
 138:DPS310.c      **** 	tmp1=DPS310_read_8(0x1C);
 139:DPS310.c      **** 	_delay_ms(verz);
 140:DPS310.c      **** 	tmp2=DPS310_read_8(0x1D);
 141:DPS310.c      **** 	_delay_ms(verz);
 142:DPS310.c      **** 	C20 = make_signed_16(tmp1, tmp2);
 143:DPS310.c      **** 	tmp1=DPS310_read_8(0x1E);
 144:DPS310.c      **** 	_delay_ms(verz);
 145:DPS310.c      **** 	tmp2=DPS310_read_8(0x1F);
 146:DPS310.c      **** 	_delay_ms(verz);
 147:DPS310.c      **** 	C21 = make_signed_16(tmp1, tmp2);
 148:DPS310.c      **** 	tmp1=DPS310_read_8(0x20);
 149:DPS310.c      **** 	_delay_ms(verz);
 150:DPS310.c      **** 	tmp2=DPS310_read_8(0x21);
 151:DPS310.c      **** 	_delay_ms(verz);
 152:DPS310.c      **** 	C30 = make_signed_16(tmp1, tmp2);
 153:DPS310.c      **** 	* */
 154:DPS310.c      **** }
 402               		.loc 1 154 0
 403 018c C901      		movw r24,r18
 404               	.LVL60:
 405               	/* epilogue start */
 406 018e DF91      		pop r29
 407 0190 CF91      		pop r28
 408               	.LVL61:
 409 0192 0895      		ret
 410               		.cfi_endproc
 411               	.LFE9:
 413               	.global	DPS310_get_raw_temp
 415               	DPS310_get_raw_temp:
 416               	.LFB10:
 155:DPS310.c      **** int32_t DPS310_get_raw_temp(void)
 156:DPS310.c      **** {
 417               		.loc 1 156 0
 418               		.cfi_startproc
 419 0194 CF93      		push r28
 420               	.LCFI5:
 421               		.cfi_def_cfa_offset 3
 422               		.cfi_offset 28, -2
 423 0196 DF93      		push r29
 424               	.LCFI6:
 425               		.cfi_def_cfa_offset 4
 426               		.cfi_offset 29, -3
 427               	/* prologue: function */
 428               	/* frame size = 0 */
 429               	/* stack size = 2 */
 430               	.L__stack_usage = 2
 431               	.LVL62:
 157:DPS310.c      **** 	uint8_t tmp0=0;
 158:DPS310.c      **** 	uint8_t tmp1=0;
 159:DPS310.c      **** 	uint8_t tmp2=0;
 160:DPS310.c      **** 	uint16_t tmp16=0;//	
 161:DPS310.c      **** 	uint32_t tmp32=0;
 162:DPS310.c      **** 	int32_t ret=0;
 163:DPS310.c      **** 	uint8_t verz=100; //Verzoegerund für Auslesen aus Register
 164:DPS310.c      **** 
 165:DPS310.c      **** 
 166:DPS310.c      **** 	
 167:DPS310.c      **** 		
 168:DPS310.c      **** 	tmp2=DPS310_read_8(TMP_B2);	//MSB rohdaten aus Sensor auslesen
 432               		.loc 1 168 0
 433 0198 83E0      		ldi r24,lo8(3)
 434 019a 0E94 0000 		call DPS310_read_8
 435               	.LVL63:
 436 019e C82F      		mov r28,r24
 437               	.LVL64:
 438               	.LBB64:
 439               	.LBB65:
 440               		.loc 2 187 0
 441 01a0 2FEF      		ldi r18,lo8(319999)
 442 01a2 31EE      		ldi r19,hi8(319999)
 443 01a4 84E0      		ldi r24,hlo8(319999)
 444 01a6 2150      	1:	subi r18,1
 445 01a8 3040      		sbci r19,0
 446 01aa 8040      		sbci r24,0
 447 01ac 01F4      		brne 1b
 448               	.LVL65:
 449 01ae 00C0      		rjmp .
 450 01b0 0000      		nop
 451               	.LVL66:
 452               	.LBE65:
 453               	.LBE64:
 169:DPS310.c      **** 	_delay_ms(verz);
 170:DPS310.c      **** 	tmp1=DPS310_read_8(TMP_B1);	//mittleres Bit auslesen
 454               		.loc 1 170 0
 455 01b2 84E0      		ldi r24,lo8(4)
 456 01b4 0E94 0000 		call DPS310_read_8
 457               	.LVL67:
 458 01b8 D82F      		mov r29,r24
 459               	.LVL68:
 460               	.LBB66:
 461               	.LBB67:
 462               		.loc 2 187 0
 463 01ba 9FEF      		ldi r25,lo8(319999)
 464 01bc 21EE      		ldi r18,hi8(319999)
 465 01be 34E0      		ldi r19,hlo8(319999)
 466 01c0 9150      	1:	subi r25,1
 467 01c2 2040      		sbci r18,0
 468 01c4 3040      		sbci r19,0
 469 01c6 01F4      		brne 1b
 470 01c8 00C0      		rjmp .
 471 01ca 0000      		nop
 472               	.LVL69:
 473               	.LBE67:
 474               	.LBE66:
 171:DPS310.c      **** 	_delay_ms(verz);
 172:DPS310.c      **** 	tmp0=DPS310_read_8(TMP_B0);	//LSB auslesen
 475               		.loc 1 172 0
 476 01cc 85E0      		ldi r24,lo8(5)
 477               	.LVL70:
 478 01ce 0E94 0000 		call DPS310_read_8
 479               	.LVL71:
 480 01d2 282F      		mov r18,r24
 481               	.LVL72:
 482               	.LBB68:
 483               	.LBB69:
 484               		.loc 2 187 0
 485 01d4 8FEF      		ldi r24,lo8(319999)
 486 01d6 91EE      		ldi r25,hi8(319999)
 487 01d8 34E0      		ldi r19,hlo8(319999)
 488 01da 8150      	1:	subi r24,1
 489 01dc 9040      		sbci r25,0
 490 01de 3040      		sbci r19,0
 491 01e0 01F4      		brne 1b
 492 01e2 00C0      		rjmp .
 493 01e4 0000      		nop
 494               	.LVL73:
 495               	.LBE69:
 496               	.LBE68:
 173:DPS310.c      **** 	_delay_ms(verz);
 174:DPS310.c      **** 	
 175:DPS310.c      **** 	
 176:DPS310.c      **** 	tmp16 = ((uint16_t)tmp2<<8) | tmp1;	//schiebe MSB 8 Schritte links
 497               		.loc 1 176 0
 498 01e6 7C2F      		mov r23,r28
 499 01e8 6D2F      		mov r22,r29
 177:DPS310.c      **** 	tmp32 = tmp16;				//16 Bit Variable in 32 Bit Variable kopieren
 500               		.loc 1 177 0
 501 01ea 90E0      		ldi r25,0
 502 01ec 80E0      		ldi r24,0
 178:DPS310.c      **** 	tmp32 = (tmp32<<8) | tmp0;	//LSB hinzufügen
 503               		.loc 1 178 0
 504 01ee 982F      		mov r25,r24
 505 01f0 872F      		mov r24,r23
 506 01f2 762F      		mov r23,r22
 507 01f4 6627      		clr r22
 508               	.LVL74:
 509 01f6 622B      		or r22,r18
 510               	.LVL75:
 511               	/* epilogue start */
 179:DPS310.c      **** 	
 180:DPS310.c      **** /*	if(tmp32 >= 8388608)		//Vorzeichenbit gesetzt
 181:DPS310.c      **** 	{
 182:DPS310.c      **** 		tmp32 -= 8388608;		//Wertigkeit von Vorzeichenbit abzählen
 183:DPS310.c      **** 		ret = 0 -((int32_t)tmp32);
 184:DPS310.c      **** 	}else ret = (int32_t)tmp32;
 185:DPS310.c      **** 	ret = (int32_t)tmp32;
 186:DPS310.c      ****  */
 187:DPS310.c      **** 	ret = tmp32;
 188:DPS310.c      ****   return ret;
 189:DPS310.c      **** }
 512               		.loc 1 189 0
 513 01f8 DF91      		pop r29
 514               	.LVL76:
 515 01fa CF91      		pop r28
 516               	.LVL77:
 517 01fc 0895      		ret
 518               		.cfi_endproc
 519               	.LFE10:
 521               	.global	__floatsisf
 522               	.global	__mulsf3
 523               	.global	__fixsfsi
 524               	.global	calculate_temperature_pressure
 526               	calculate_temperature_pressure:
 527               	.LFB11:
 190:DPS310.c      **** 
 191:DPS310.c      **** int32_t calculate_temperature_pressure(void)
 192:DPS310.c      **** {
 528               		.loc 1 192 0
 529               		.cfi_startproc
 530               	/* prologue: function */
 531               	/* frame size = 0 */
 532               	/* stack size = 0 */
 533               	.L__stack_usage = 0
 534               	.LVL78:
 535               	.LBB70:
 536               	.LBB71:
 537               		.loc 2 187 0
 538 01fe 2FEF      		ldi r18,lo8(319999)
 539 0200 81EE      		ldi r24,hi8(319999)
 540 0202 94E0      		ldi r25,hlo8(319999)
 541 0204 2150      	1:	subi r18,1
 542 0206 8040      		sbci r24,0
 543 0208 9040      		sbci r25,0
 544 020a 01F4      		brne 1b
 545 020c 00C0      		rjmp .
 546 020e 0000      		nop
 547               	.LVL79:
 548               	.LBE71:
 549               	.LBE70:
 193:DPS310.c      **** 	float Temperature=0;
 194:DPS310.c      ****        long temptemp = 0;
 195:DPS310.c      ****        Temperature=0;
 196:DPS310.c      ****       
 197:DPS310.c      ****      _delay_ms(100);
 198:DPS310.c      **** 	DPS310_write(PRS_CFG, 0x01);
 550               		.loc 1 198 0
 551 0210 61E0      		ldi r22,lo8(1)
 552 0212 86E0      		ldi r24,lo8(6)
 553 0214 0E94 0000 		call DPS310_write
 554               	.LVL80:
 555               	.LBB72:
 556               	.LBB73:
 557               		.loc 2 187 0
 558 0218 2FEF      		ldi r18,lo8(319999)
 559 021a 81EE      		ldi r24,hi8(319999)
 560 021c 94E0      		ldi r25,hlo8(319999)
 561 021e 2150      	1:	subi r18,1
 562 0220 8040      		sbci r24,0
 563 0222 9040      		sbci r25,0
 564 0224 01F4      		brne 1b
 565 0226 00C0      		rjmp .
 566 0228 0000      		nop
 567               	.LVL81:
 568               	.LBE73:
 569               	.LBE72:
 199:DPS310.c      **** 	_delay_ms(100);
 200:DPS310.c      **** 	DPS310_write(TMP_CFG, 0x80);//1 Messung / sec 8 mal oversampling
 570               		.loc 1 200 0
 571 022a 60E8      		ldi r22,lo8(-128)
 572 022c 87E0      		ldi r24,lo8(7)
 573 022e 0E94 0000 		call DPS310_write
 574               	.LVL82:
 575               	.LBB74:
 576               	.LBB75:
 577               		.loc 2 187 0
 578 0232 2FEF      		ldi r18,lo8(319999)
 579 0234 81EE      		ldi r24,hi8(319999)
 580 0236 94E0      		ldi r25,hlo8(319999)
 581 0238 2150      	1:	subi r18,1
 582 023a 8040      		sbci r24,0
 583 023c 9040      		sbci r25,0
 584 023e 01F4      		brne 1b
 585 0240 00C0      		rjmp .
 586 0242 0000      		nop
 587               	.LVL83:
 588               	.LBE75:
 589               	.LBE74:
 201:DPS310.c      **** 	_delay_ms(100);
 202:DPS310.c      **** 	DPS310_write(0x08, 0x07);
 590               		.loc 1 202 0
 591 0244 67E0      		ldi r22,lo8(7)
 592 0246 88E0      		ldi r24,lo8(8)
 593 0248 0E94 0000 		call DPS310_write
 594               	.LVL84:
 595               	.LBB76:
 596               	.LBB77:
 597               		.loc 2 187 0
 598 024c 2FEF      		ldi r18,lo8(319999)
 599 024e 81EE      		ldi r24,hi8(319999)
 600 0250 94E0      		ldi r25,hlo8(319999)
 601 0252 2150      	1:	subi r18,1
 602 0254 8040      		sbci r24,0
 603 0256 9040      		sbci r25,0
 604 0258 01F4      		brne 1b
 605 025a 00C0      		rjmp .
 606 025c 0000      		nop
 607               	.LVL85:
 608               	.LBE77:
 609               	.LBE76:
 203:DPS310.c      **** 	_delay_ms(100);
 204:DPS310.c      ****        
 205:DPS310.c      ****        
 206:DPS310.c      ****        
 207:DPS310.c      ****        
 208:DPS310.c      ****        Temperature=(float)DPS310_get_raw_temp();
 610               		.loc 1 208 0
 611 025e 0E94 0000 		call DPS310_get_raw_temp
 612               	.LVL86:
 613 0262 0E94 0000 		call __floatsisf
 614               	.LVL87:
 209:DPS310.c      ****        Temperature/=524288;
 615               		.loc 1 209 0
 616 0266 20E0      		ldi r18,0
 617 0268 30E0      		ldi r19,0
 618 026a 40E0      		ldi r20,0
 619 026c 56E3      		ldi r21,lo8(54)
 620 026e 0E94 0000 		call __mulsf3
 621               	.LVL88:
 210:DPS310.c      ****        temptemp = Temperature;
 622               		.loc 1 210 0
 623 0272 0E94 0000 		call __fixsfsi
 624               	.LVL89:
 625               	/* epilogue start */
 211:DPS310.c      ****      return temptemp;
 212:DPS310.c      **** }
 626               		.loc 1 212 0
 627 0276 0895      		ret
 628               		.cfi_endproc
 629               	.LFE11:
 631               	.global	DPS310_get_raw_pres
 633               	DPS310_get_raw_pres:
 634               	.LFB12:
 213:DPS310.c      **** 
 214:DPS310.c      **** 
 215:DPS310.c      **** 
 216:DPS310.c      **** uint32_t DPS310_get_raw_pres(void)
 217:DPS310.c      **** {
 635               		.loc 1 217 0
 636               		.cfi_startproc
 637               	/* prologue: function */
 638               	/* frame size = 0 */
 639               	/* stack size = 0 */
 640               	.L__stack_usage = 0
 641               	.LVL90:
 218:DPS310.c      **** 	uint8_t tmp0=0;
 219:DPS310.c      **** 	uint8_t tmp1=0;
 220:DPS310.c      **** 	uint8_t tmp2=0;
 221:DPS310.c      **** 	uint16_t tmp16=0;
 222:DPS310.c      **** 	uint32_t tmp32=0;
 223:DPS310.c      **** 	int32_t ret=0;
 224:DPS310.c      **** 	uint8_t verz=100; //Verzoegerund für Auslesen aus Register
 225:DPS310.c      **** 	
 226:DPS310.c      **** 	DPS310_write(0x08, 0x02);//eine temp messung auslösen
 642               		.loc 1 226 0
 643 0278 62E0      		ldi r22,lo8(2)
 644 027a 88E0      		ldi r24,lo8(8)
 645 027c 0E94 0000 		call DPS310_write
 646               	.LVL91:
 647               	.LBB78:
 648               	.LBB79:
 649               		.loc 2 187 0
 650 0280 2FEF      		ldi r18,lo8(319999)
 651 0282 81EE      		ldi r24,hi8(319999)
 652 0284 94E0      		ldi r25,hlo8(319999)
 653 0286 2150      	1:	subi r18,1
 654 0288 8040      		sbci r24,0
 655 028a 9040      		sbci r25,0
 656 028c 01F4      		brne 1b
 657 028e 00C0      		rjmp .
 658 0290 0000      		nop
 659               	.LVL92:
 660               	.LBE79:
 661               	.LBE78:
 227:DPS310.c      **** 	_delay_ms(100);
 228:DPS310.c      **** 		
 229:DPS310.c      **** 	tmp2=DPS310_read_8(PSR_B2);	//MSB rohdaten aus Sensor auslesen
 662               		.loc 1 229 0
 663 0292 80E0      		ldi r24,0
 664 0294 0E94 0000 		call DPS310_read_8
 665               	.LVL93:
 666               	.LBB80:
 667               	.LBB81:
 668               		.loc 2 187 0
 669 0298 2FEF      		ldi r18,lo8(319999)
 670 029a 81EE      		ldi r24,hi8(319999)
 671 029c 94E0      		ldi r25,hlo8(319999)
 672 029e 2150      	1:	subi r18,1
 673 02a0 8040      		sbci r24,0
 674 02a2 9040      		sbci r25,0
 675 02a4 01F4      		brne 1b
 676 02a6 00C0      		rjmp .
 677 02a8 0000      		nop
 678               	.LVL94:
 679               	.LBE81:
 680               	.LBE80:
 230:DPS310.c      **** 	_delay_ms(verz);
 231:DPS310.c      **** 	tmp1=DPS310_read_8(PSR_B1);	//mittleres Bit auslesen
 681               		.loc 1 231 0
 682 02aa 81E0      		ldi r24,lo8(1)
 683 02ac 0E94 0000 		call DPS310_read_8
 684               	.LVL95:
 685               	.LBB82:
 686               	.LBB83:
 687               		.loc 2 187 0
 688 02b0 2FEF      		ldi r18,lo8(319999)
 689 02b2 81EE      		ldi r24,hi8(319999)
 690 02b4 94E0      		ldi r25,hlo8(319999)
 691 02b6 2150      	1:	subi r18,1
 692 02b8 8040      		sbci r24,0
 693 02ba 9040      		sbci r25,0
 694 02bc 01F4      		brne 1b
 695 02be 00C0      		rjmp .
 696 02c0 0000      		nop
 697               	.LVL96:
 698               	.LBE83:
 699               	.LBE82:
 232:DPS310.c      **** 	_delay_ms(verz);
 233:DPS310.c      **** 	tmp0=DPS310_read_8(PSR_B0);	//LSB auslesen
 700               		.loc 1 233 0
 701 02c2 82E0      		ldi r24,lo8(2)
 702 02c4 0E94 0000 		call DPS310_read_8
 703               	.LVL97:
 704               	.LBB84:
 705               	.LBB85:
 706               		.loc 2 187 0
 707 02c8 2FEF      		ldi r18,lo8(319999)
 708 02ca 81EE      		ldi r24,hi8(319999)
 709 02cc 94E0      		ldi r25,hlo8(319999)
 710 02ce 2150      	1:	subi r18,1
 711 02d0 8040      		sbci r24,0
 712 02d2 9040      		sbci r25,0
 713 02d4 01F4      		brne 1b
 714 02d6 00C0      		rjmp .
 715 02d8 0000      		nop
 716               	.LVL98:
 717               	.LBE85:
 718               	.LBE84:
 234:DPS310.c      **** 	_delay_ms(verz);
 235:DPS310.c      **** 	
 236:DPS310.c      **** 	//ret=((((long)tmp2<<8)|tmp1)<<8)|tmp0;
 237:DPS310.c      ****     //ret=(ret<<8)>>8;
 238:DPS310.c      ****     
 239:DPS310.c      **** 	//value=((((long)temp_data[0]<<8)|temp_data[1])<<8)|temp_data[2];
 240:DPS310.c      **** 	
 241:DPS310.c      **** 
 242:DPS310.c      **** 	tmp16 = (tmp2<<8) | tmp1;	//schiebe MSB 8 Schritte links
 243:DPS310.c      **** 	tmp32 = tmp16;				//16 Bit Variable in 32 Bit Variable kopieren
 244:DPS310.c      **** 	tmp32 = (tmp32<<8) | tmp0;	//LSB hinzufügen
 245:DPS310.c      **** 	
 246:DPS310.c      **** 	/*
 247:DPS310.c      **** 	if(tmp32 >= 8388608)		//Vorzeichenbit gesetzt
 248:DPS310.c      **** 	{
 249:DPS310.c      **** 		tmp32 -= 8388608;		//Wertigkeit von Vorzeichenbit abzählen
 250:DPS310.c      **** 		ret = 0 -((int32_t)tmp32);
 251:DPS310.c      **** 	}else ret = (int32_t)tmp32;
 252:DPS310.c      ****   //  ret=(ret<<8)>>8;
 253:DPS310.c      **** 	
 254:DPS310.c      **** 	*/
 255:DPS310.c      **** 	return ret;
 256:DPS310.c      **** 	
 257:DPS310.c      **** }
 719               		.loc 1 257 0
 720 02da 60E0      		ldi r22,0
 721 02dc 70E0      		ldi r23,0
 722 02de CB01      		movw r24,r22
 723               	/* epilogue start */
 724 02e0 0895      		ret
 725               		.cfi_endproc
 726               	.LFE12:
 728               	.global	__floatunsisf
 729               	.global	__addsf3
 730               	.global	DPS310_get_komp_temp
 732               	DPS310_get_komp_temp:
 733               	.LFB13:
 258:DPS310.c      **** 
 259:DPS310.c      **** 
 260:DPS310.c      **** 
 261:DPS310.c      **** int32_t DPS310_get_komp_temp(void)
 262:DPS310.c      **** {
 734               		.loc 1 262 0
 735               		.cfi_startproc
 736 02e2 CF92      		push r12
 737               	.LCFI7:
 738               		.cfi_def_cfa_offset 3
 739               		.cfi_offset 12, -2
 740 02e4 DF92      		push r13
 741               	.LCFI8:
 742               		.cfi_def_cfa_offset 4
 743               		.cfi_offset 13, -3
 744 02e6 EF92      		push r14
 745               	.LCFI9:
 746               		.cfi_def_cfa_offset 5
 747               		.cfi_offset 14, -4
 748 02e8 FF92      		push r15
 749               	.LCFI10:
 750               		.cfi_def_cfa_offset 6
 751               		.cfi_offset 15, -5
 752 02ea CF93      		push r28
 753               	.LCFI11:
 754               		.cfi_def_cfa_offset 7
 755               		.cfi_offset 28, -6
 756               	/* prologue: function */
 757               	/* frame size = 0 */
 758               	/* stack size = 5 */
 759               	.L__stack_usage = 5
 760               	.LVL99:
 263:DPS310.c      **** 	uint8_t tmp0=0;
 264:DPS310.c      **** 	uint8_t tmp1=0;
 265:DPS310.c      **** 	uint8_t tmp2=0;
 266:DPS310.c      **** 	uint16_t tmp16=0;
 267:DPS310.c      **** 	uint32_t tmp32=0;
 268:DPS310.c      **** 	int32_t ret=0;
 269:DPS310.c      **** 	int32_t temp_raw_sc=0;
 270:DPS310.c      **** 	int32_t temp_raw=0;
 271:DPS310.c      **** 	uint8_t verz=10; //Verzoegerund für Auslesen aus Register
 272:DPS310.c      **** 		
 273:DPS310.c      **** 	tmp2=DPS310_read_8(TMP_B2);	//MSB rohdaten aus Sensor auslesen
 761               		.loc 1 273 0
 762 02ec 83E0      		ldi r24,lo8(3)
 763 02ee 0E94 0000 		call DPS310_read_8
 764               	.LVL100:
 765 02f2 C82F      		mov r28,r24
 766               	.LVL101:
 767               	.LBB86:
 768               	.LBB87:
 769               		.loc 2 187 0
 770 02f4 8FE3      		ldi r24,lo8(-25537)
 771 02f6 9CE9      		ldi r25,hi8(-25537)
 772 02f8 0197      	1:	sbiw r24,1
 773 02fa 01F4      		brne 1b
 774               	.LVL102:
 775 02fc 00C0      		rjmp .
 776 02fe 0000      		nop
 777               	.LVL103:
 778               	.LBE87:
 779               	.LBE86:
 274:DPS310.c      **** 	_delay_ms(verz);
 275:DPS310.c      **** 	tmp1=DPS310_read_8(TMP_B1);	//mittleres Bit auslesen
 780               		.loc 1 275 0
 781 0300 84E0      		ldi r24,lo8(4)
 782 0302 0E94 0000 		call DPS310_read_8
 783               	.LVL104:
 784 0306 F82E      		mov r15,r24
 785               	.LVL105:
 786               	.LBB88:
 787               	.LBB89:
 788               		.loc 2 187 0
 789 0308 8FE3      		ldi r24,lo8(-25537)
 790 030a 9CE9      		ldi r25,hi8(-25537)
 791 030c 0197      	1:	sbiw r24,1
 792 030e 01F4      		brne 1b
 793 0310 00C0      		rjmp .
 794 0312 0000      		nop
 795               	.LVL106:
 796               	.LBE89:
 797               	.LBE88:
 276:DPS310.c      **** 	_delay_ms(verz);
 277:DPS310.c      **** 	tmp0=DPS310_read_8(TMP_B0);	//LSB auslesen
 798               		.loc 1 277 0
 799 0314 85E0      		ldi r24,lo8(5)
 800 0316 0E94 0000 		call DPS310_read_8
 801               	.LVL107:
 802 031a 282F      		mov r18,r24
 803               	.LVL108:
 804               	.LBB90:
 805               	.LBB91:
 806               		.loc 2 187 0
 807 031c 8FE3      		ldi r24,lo8(-25537)
 808 031e 9CE9      		ldi r25,hi8(-25537)
 809 0320 0197      	1:	sbiw r24,1
 810 0322 01F4      		brne 1b
 811 0324 00C0      		rjmp .
 812 0326 0000      		nop
 813               	.LVL109:
 814               	.LBE91:
 815               	.LBE90:
 278:DPS310.c      **** 	_delay_ms(verz);
 279:DPS310.c      **** 	
 280:DPS310.c      **** 	tmp16 = (tmp2<<8) | tmp1;	//schiebe MSB 8 Schritte links
 816               		.loc 1 280 0
 817 0328 7C2F      		mov r23,r28
 818 032a 6F2D      		mov r22,r15
 281:DPS310.c      **** 	tmp32 = tmp16;				//16 Bit Variable in 32 Bit Variable kopieren
 819               		.loc 1 281 0
 820 032c 90E0      		ldi r25,0
 821 032e 80E0      		ldi r24,0
 282:DPS310.c      **** 	tmp32 = (tmp32<<8) | tmp0;	//LSB hinzufügen
 822               		.loc 1 282 0
 823 0330 982F      		mov r25,r24
 824 0332 872F      		mov r24,r23
 825 0334 762F      		mov r23,r22
 826 0336 6627      		clr r22
 827 0338 622B      		or r22,r18
 828               	.LVL110:
 283:DPS310.c      **** 	
 284:DPS310.c      **** 	if(tmp32 >= 8388608)		//Vorzeichenbit gesetzt
 829               		.loc 1 284 0
 830 033a 6115      		cp r22,__zero_reg__
 831 033c 7105      		cpc r23,__zero_reg__
 832 033e 20E8      		ldi r18,-128
 833 0340 8207      		cpc r24,r18
 834 0342 9105      		cpc r25,__zero_reg__
 835               	.LVL111:
 836 0344 00F0      		brlo .L22
 837               	.LVL112:
 285:DPS310.c      **** 	{
 286:DPS310.c      **** 		tmp32 -= 8388608;		//Wertigkeit von Vorzeichenbit abzählen
 838               		.loc 1 286 0
 839 0346 8058      		subi r24,-128
 840 0348 9109      		sbc r25,__zero_reg__
 841               	.LVL113:
 287:DPS310.c      **** 		temp_raw = 0 -((int32_t)tmp32);
 842               		.loc 1 287 0
 843 034a 9095      		com r25
 844 034c 8095      		com r24
 845 034e 7095      		com r23
 846 0350 6195      		neg r22
 847 0352 7F4F      		sbci r23,lo8(-1)
 848 0354 8F4F      		sbci r24,lo8(-1)
 849 0356 9F4F      		sbci r25,lo8(-1)
 850               	.LVL114:
 851               	.L21:
 288:DPS310.c      **** 	}else ret = (int32_t)tmp32;
 289:DPS310.c      **** 	
 290:DPS310.c      **** 	temp_raw_sc=temp_raw / 7864320;
 291:DPS310.c      **** 	ret = (C0*0.5)+(C1*temp_raw_sc);
 852               		.loc 1 291 0
 853 0358 E090 0000 		lds r14,C1
 854 035c F090 0000 		lds r15,C1+1
 290:DPS310.c      **** 	ret = (C0*0.5)+(C1*temp_raw_sc);
 855               		.loc 1 290 0
 856 0360 20E0      		ldi r18,0
 857 0362 30E0      		ldi r19,0
 858 0364 48E7      		ldi r20,lo8(120)
 859 0366 50E0      		ldi r21,0
 860 0368 0E94 0000 		call __divmodsi4
 861               	.LVL115:
 862               		.loc 1 291 0
 863 036c D701      		movw r26,r14
 864 036e 0E94 0000 		call __muluhisi3
 865 0372 0E94 0000 		call __floatsisf
 866               	.LVL116:
 867 0376 6B01      		movw r12,r22
 868 0378 7C01      		movw r14,r24
 869 037a 6091 0000 		lds r22,C0
 870 037e 7091 0000 		lds r23,C0+1
 871 0382 90E0      		ldi r25,0
 872 0384 80E0      		ldi r24,0
 873 0386 0E94 0000 		call __floatunsisf
 874               	.LVL117:
 875 038a 20E0      		ldi r18,0
 876 038c 30E0      		ldi r19,0
 877 038e 40E0      		ldi r20,0
 878 0390 5FE3      		ldi r21,lo8(63)
 879 0392 0E94 0000 		call __mulsf3
 880               	.LVL118:
 881 0396 9B01      		movw r18,r22
 882 0398 AC01      		movw r20,r24
 883 039a C701      		movw r24,r14
 884 039c B601      		movw r22,r12
 885 039e 0E94 0000 		call __addsf3
 886               	.LVL119:
 887 03a2 0E94 0000 		call __fixsfsi
 888               	.LVL120:
 889               	/* epilogue start */
 292:DPS310.c      ****     
 293:DPS310.c      **** 	return ret;
 294:DPS310.c      **** }
 890               		.loc 1 294 0
 891 03a6 CF91      		pop r28
 892               	.LVL121:
 893 03a8 FF90      		pop r15
 894               	.LVL122:
 895 03aa EF90      		pop r14
 896 03ac DF90      		pop r13
 897 03ae CF90      		pop r12
 898 03b0 0895      		ret
 899               	.LVL123:
 900               	.L22:
 270:DPS310.c      **** 	uint8_t verz=10; //Verzoegerund für Auslesen aus Register
 901               		.loc 1 270 0
 902 03b2 60E0      		ldi r22,0
 903 03b4 70E0      		ldi r23,0
 904 03b6 CB01      		movw r24,r22
 905               	.LVL124:
 906 03b8 00C0      		rjmp .L21
 907               		.cfi_endproc
 908               	.LFE13:
 910               	.global	C1
 911               		.section .bss
 914               	C1:
 915 0000 0000      		.zero	2
 916               	.global	C0
 919               	C0:
 920 0002 0000      		.zero	2
 921               		.text
 922               	.Letext0:
 923               		.file 3 "/usr/avr/include/stdint.h"
 924               		.file 4 "grn_TWI.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 DPS310.c
     /tmp/cc9cVBVj.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9cVBVj.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9cVBVj.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9cVBVj.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9cVBVj.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9cVBVj.s:12     .text:0000000000000000 make_signed_16
     /tmp/cc9cVBVj.s:46     .text:0000000000000012 DPS310_read_8
     /tmp/cc9cVBVj.s:144    .text:0000000000000076 DPS310_write
     /tmp/cc9cVBVj.s:244    .text:00000000000000d0 DPS310_init
     /tmp/cc9cVBVj.s:919    .bss:0000000000000002 C0
     /tmp/cc9cVBVj.s:914    .bss:0000000000000000 C1
     /tmp/cc9cVBVj.s:415    .text:0000000000000194 DPS310_get_raw_temp
     /tmp/cc9cVBVj.s:526    .text:00000000000001fe calculate_temperature_pressure
     /tmp/cc9cVBVj.s:633    .text:0000000000000278 DPS310_get_raw_pres
     /tmp/cc9cVBVj.s:732    .text:00000000000002e2 DPS310_get_komp_temp

UNDEFINED SYMBOLS
TWIStart
TWIGetStatus
TWIWrite
TWIReadNACK
TWIStop
__floatsisf
__mulsf3
__fixsfsi
__floatunsisf
__addsf3
__divmodsi4
__muluhisi3
__do_clear_bss
